#!/bin/bash
#
# ank - Ankaios wrapper maintaining original command syntax
# Usage: ank -k apply config/test.yaml
#

set -e

DASHBOARD_URL="${DASHBOARD_URL:-http://localhost:5001}"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m'

log_info() { echo -e "${BLUE}[INFO]${NC} $1" >&2; }
log_success() { echo -e "${GREEN}[SUCCESS]${NC} $1" >&2; }
log_error() { echo -e "${RED}[ERROR]${NC} $1" >&2; }

# Validate config through dashboard if available. Uses public validate endpoint
# and falls back to local remediation if validation fails.
validate_config() {
    local config_file="$1"

    if [[ ! -f "$config_file" ]]; then
        log_error "Config file not found: $config_file"
        return 1
    fi

    # Prefer dashboard public validator (no auth): /api/validate-config
    if command -v curl &> /dev/null && command -v jq &> /dev/null; then
        log_info "Validating configuration: $config_file"

        local validation_result
        validation_result=$(curl -s -X POST "${DASHBOARD_URL}/api/validate-config" \
            -H "Content-Type: application/json" \
            -d "{\"config\": $(jq -Rs . < "$config_file")}" 2>/dev/null || echo "")

        if [[ -z "$validation_result" ]]; then
            log_error "No response from dashboard validator; proceeding with original config"
            return 0
        fi

        # If overall_status == PASSED -> return success
        if echo "$validation_result" | jq -e '.overall_status == "PASSED"' > /dev/null 2>&1; then
            log_success "Configuration validated!"
            return 0
        fi

        # Validation failed: print detailed issues
        log_error "Validation FAILED for $config_file. Details:"
        echo "$validation_result" | jq -r '.tests[] | "- [\(.name)] \(.status)\n  issues: \(.issues // [])"' >&2

        # If validation failed, attempt local remediation using repo's remediator
        log_info "Attempting auto-heal locally"

        issues_file=$(mktemp)
        echo "$validation_result" | jq -c '[.tests[].issues[]]' > "$issues_file"

        healed_json=$(python3 - "$config_file" "$issues_file" 2>/dev/null <<'PY'
import sys, json
from pathlib import Path
sys.path.insert(0, str(Path(__file__).resolve().parents[2]))
out = {'fixed': None, 'log': []}
try:
    from app.validators.config_remediator import ConfigurationRemediator
    cfg_path = sys.argv[1]
    issues_path = sys.argv[2]
    with open(cfg_path, 'r') as f:
        cfg = f.read()
    with open(issues_path, 'r') as f:
        issues = json.load(f)
    rem = ConfigurationRemediator()
    fixed_yaml, log = rem.auto_fix(cfg, issues)
    out['fixed'] = fixed_yaml
    out['log'] = log
except Exception as e:
    out['log'] = [f'REM_EDITOR_IMPORT_ERROR: {str(e)}']
print(json.dumps(out))
PY

)

    # cleanup issues file
        rm -f "$issues_file"

        # parse healed_json
        healed_fixed=$(echo "$healed_json" | jq -r '.fixed')

        if [[ -n "$healed_fixed" && "$healed_fixed" != "null" ]]; then
            # Show remediation log
            log_info "Remediation log:"
            echo "$healed_json" | jq -r '.log[]' >&2

            # Backup original and persist healed config so next run passes
            backup_file="${config_file}.bak.$(date +%s)"
            cp "$config_file" "$backup_file"

            # Persist healed config directly (remediator outputs YAML)
            printf '%s' "$healed_fixed" > "$config_file"
            log_success "Healed configuration persisted to $config_file (backup: $backup_file)"

            # Re-validate the healed config by re-reading from disk
            sleep 0.1
            reval=$(curl -s -X POST "${DASHBOARD_URL}/api/validate-config" \
                -H "Content-Type: application/json" \
                -d "{\"config\": $(jq -Rs . < "$config_file")}" || echo "")
            if [[ -n "$reval" ]] && echo "$reval" | jq -e '.overall_status == "PASSED"' > /dev/null 2>&1; then
                log_success "Healed config validated successfully"
                return 0
            else
                log_error "Healed config did not fully validate. Remaining issues:" >&2
                echo "$reval" | jq '.tests[] | select(.status == "FAILED")' >&2
                # leave healed file persisted but return failure to avoid blind apply
                return 1
            fi
        else
            log_error "Auto-heal did not produce a healed configuration; aborting apply"
            return 1
        fi
    fi

    return 0
}

# Main: Handle -k apply command (your original syntax)
if [[ "$1" == "-k" && "$2" == "apply" ]]; then
    # Support multiple config files (e.g. config/*.yaml). Iterate over all
    # provided file arguments after the `apply` subcommand.
    shift 2

    if [[ $# -eq 0 ]]; then
        log_error "No config file(s) specified"
        exit 1
    fi

    success_any=0
    failure_any=0

    for config_file in "$@"; do
        if [[ ! -f "$config_file" ]]; then
            log_error "Config file not found: $config_file"
            failure_any=1
            continue
        fi

        log_info "Validating configuration: $config_file"
        if ! validate_config "$config_file"; then
            log_error "Validation/Remediation failed for $config_file; skipping apply"
            failure_any=1
            continue
        fi

        log_info "Applying configuration: $config_file"
        if ank -k apply "$config_file"; then
            log_success "Configuration applied: $config_file"
            success_any=1
        else
            log_error "ank apply failed for $config_file"
            failure_any=1
        fi
    done

    if [[ $failure_any -ne 0 && $success_any -eq 0 ]]; then
        log_error "No configurations were successfully applied"
        exit 1
    fi

    exit 0
fi

# Pass all other commands directly to ank CLI
ank "$@"
